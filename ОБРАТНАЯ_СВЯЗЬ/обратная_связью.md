Обратная связь по тестовому заданию FE-1

Привет, Наиль!

Спасибо за ваш интерес к нашей вакансии и время, которое вы уделили выполнению тестового задания FE-1. Мы внимательно рассмотрели ваше решение и хотели бы поделиться обратной связью.

В целом, вы успешно справились с созданием основного интерфейса приложения для нашего вымышленного магазина. Нам понравилось, что вы смогли реализовать визуальную часть, соответствующую макетам, и базовую логику взаимодействия.

**Что получилось хорошо:**

*   **Интерфейс и основные компоненты:** Вы создали структуру приложения с меню навигации, заголовком и областью для контента, включая три требуемые страницы (Магазин, Корзина, Профиль), как описано в п. 5 задания. Меню корректно выезжает и складывается по нажатию кнопки (п. 1).
*   **Отображение данных:** Приложение успешно получает данные о товарах из Mockoon API с помощью `HttpClient` и отображает их в виде карточек с картинками (п. 9, п. 10). Также корректно работает прокрутка контента (п. 11).
*   **Заголовок и навигация:** Заголовок приложения динамически обновляется, отображая название текущей страницы (п. 3). Базовая навигация между страницами реализована.
*   **Логика корзины:** Вы реализовали отображение статуса наличия товара (зеленая галочка/красный крестик) в зависимости от количества в корзине и в магазине (п. 13).
*   **Стек:** Вы использовали указанный стек dotnet 8, AvaloniaUI и MVVM Community Toolkit (п. 2, п. 16).
*   **Работа в дизайнере:** Судя по наличию `Design.DataContext`, вы позаботились об отображении View в дизайнере (п. 6).

**На что стоит обратить внимание и где можно улучшить:**

*   **Строгое следование MVVM:** Это один из ключевых моментов. Мы заметили, что значительная часть логики управления UI находится в файлах code-behind (`*.axaml.cs`), а не в ViewModel. Например:
    *   Обработка кликов по кнопкам навигации (`NavigationView.axaml.cs`). По требованию п. 2, навигация должна управляться из ViewModel через команды (Commands).
    *   Реализация двойного клика для редактирования количества в корзине (`CartPageView.cs`). Это взаимодействие также лучше реализовать через команды и привязки в ViewModel (п. 12).
    *   Обработка клика по кнопке "Купить" (`ShopPageView.cs`). Логика добавления в корзину должна быть полностью в ViewModel и вызываться через команду.
    *   Логика переключения режима редактирования в профиле по правому клику мыши (`ProfilePageView.cs`). Хотя обработчик `OnTextBoxPointerPressed` есть, он не привязан к элементам управления в XAML и сама логика должна быть в ViewModel (п. 14).
        Цель MVVM - максимально отделить логику представления от самого представления, минимизируя код в code-behind.

*   **Dependency Injection (DI):** В задании явно требовалось использовать DI (п. 8) для управления зависимостями (ViewModel, сервисы, HttpClient). В вашем решении `MainWindowViewModel` и `HttpClient` создаются вручную через `new MainWindowViewModel()` и `new HttpClient()`. В реальных проектах мы используем DI-контейнеры для большей гибкости и тестируемости кода. Рекомендуем изучить, как настроить и использовать DI (например, `Microsoft.Extensions.DependencyInjection`) в Avalonia-приложениях.

*   **Структура ViewModel:** Требование п. 4 предполагало разделение главной страницы на три View *и* три ViewModel (для навигации, заголовка и контента). У вас View разделены, но используется один общий `MainWindowViewModel` для всего окна. Хотя для маленького приложения это может работать, разделение на более мелкие ViewModel улучшает структуру и поддерживаемость.

*   **Поддержка Web:** Задание требовало, чтобы приложение работало и в браузере (п. 7). В вашем файле `.csproj` нет необходимых настроек и зависимостей для сборки проекта под WebAssembly (WASM).

*   **Валидация в профиле:** Вы добавили логику проверки формата почты и телефона в модель `UserProfile` (п. 15), что хорошо. Однако, для лучшего пользовательского опыта стоит интегрировать эту валидацию с UI Avalonia, используя встроенные механизмы (например, интерфейс `INotifyDataErrorInfo` или DataAnnotations вместе со стилями `:invalid`), чтобы ошибки отображались автоматически рядом с полями ввода.

**Итог:**

Вы продемонстрировали хорошие базовые навыки работы с AvaloniaUI и C#. Основные области для дальнейшего развития, исходя из этого задания, — это более глубокое понимание и строгое применение паттерна MVVM (особенно использование команд и минимизация code-behind), освоение и применение Dependency Injection, а также понимание особенностей сборки приложений под разные платформы, включая Web.
Надеемся, эта обратная связь будет вам полезна. Еще раз спасибо за ваши старания и уделенное время!

**1) Summary по качеству кода**

Кандидат продемонстрировал базовое понимание AvaloniaUI и смог реализовать основной функционал приложения. Использован MVVM Community Toolkit, как и требовалось. Структура проекта включает разделение на Views, ViewModels и Models. UI реализован с использованием `SplitView` для меню и отдельных `UserControl` для страниц и компонентов главного окна. Загрузка данных из API через `HttpClient` выполнена.

Однако есть существенные недостатки:

*   **Нарушение MVVM:** Кандидат часто использует code-behind (`.axaml.cs`) для обработки событий UI и управления состоянием, вместо того чтобы использовать команды и привязки к ViewModel. Примеры: навигация (`NavigationView.axaml.cs`), редактирование количества в корзине (`CartPageView.cs`), попытка редактирования профиля (`ProfilePageView.cs`), обработка нажатия кнопки "Купить" (`ShopPageView.cs`). Это ключевое нарушение принципов MVVM.
*   **Отсутствие DI/IoC:** Несмотря на явное требование, Dependency Injection не используется. `MainWindowViewModel` и `HttpClient` создаются вручную (`new`). Это серьезное упущение.
*   **Монолитный ViewModel:** `MainWindowViewModel` отвечает за состояние всего приложения, включая данные всех страниц (товары, корзина, профиль пользователя), состояние навигации и меню. Хотя для такого маленького приложения это может работать, это не соответствует требованию №4 о раздельных ViewModel для частей главного окна и не масштабируется.
*   **Отсутствие поддержки Web:** В `.csproj` нет конфигурации для сборки под Web (Browser/WASM), хотя это было указано как требование.
*   **Неполная реализация некоторых требований:** Валидация в профиле реализована в модели, но не интегрирована полностью с UI для отображения ошибок стандартными средствами Avalonia. Редактирование по правому клику в профиле не реализовано (обработчик есть, но не привязан к элементам управления в XAML).
*   **Мелкие недочеты:** Есть закомментированный код, самописный `RelayCommand<T>` вместо использования встроенного в CommunityToolkit.Mvvm.

В целом, код функционален на базовом уровне, но архитектурные решения (особенно отсутствие DI и злоупотребление code-behind) не соответствуют требованиям и лучшим практикам разработки на Avalonia с MVVM.

**2) Соответствие критериям оценки**

*   ✅ **1) Меню выезжает/складывается:** Реализовано через `SplitView` и `IsPaneOpen` с командой `TogglePaneCommand`.
*   ❌ **2) Переход по нажатию на панели навигации (MVVM):** Функциональность есть, но реализована через code-behind (`Click` событие в `NavigationView.axaml.cs`), а не через MVVM Commands. *Частично выполнен (функциональность есть, реализация неверная)*.
*   ✅ **3) Обновление заголовка при переходе:** Реализовано через привязку `HeaderView` к `SelectedPageName` в `MainWindowViewModel`.
*   ❌ **4) Главная страница разделена на 3 View/ViewModel:** View разделены (`NavigationView`, `HeaderView`, `ContentView`), но для них не созданы отдельные ViewModel. Используется единый `MainWindowViewModel`. *Частично выполнен (View разделены, ViewModel нет)*.
*   ✅ **5) Наличие меню, заголовка, контейнера контента и 3 страниц:** Все компоненты и страницы присутствуют.
*   ✅ **6) Работа в дизайнере:** Настроен `Design.DataContext` для `MainWindow`, что должно обеспечивать базовую работу в дизайнере. Полная интерактивность в дизайнере (нажатие кнопок и т.д.) часто ограничена, но основное отображение должно работать. *Вероятно, выполнен*.
*   ❌ **7) Работа на Desktop и в браузере:** Нет конфигурации для сборки под браузер. *Не выполнен*.
*   ❌ **8) Использование DI/IoC:** DI не используется, зависимости создаются вручную. *Не выполнен*.
*   ✅ **9) Картинки в карточках товаров:** Картинки загружаются из сети и отображаются.
*   ✅ **10) GET запрос в API и отображение данных:** Реализовано с использованием `HttpClient` и `Newtonsoft.Json`.
*   ✅ **11) Прокрутка контента:** Используется `ScrollViewer` на страницах "Магазин" и "Корзина".
*   ❌ **12) Редактирование количества в корзине по двойному нажатию (MVVM):** Функциональность есть, но реализована через code-behind (`DoubleTapped`, `LostFocus` события в `CartPageView.cs`), а не через MVVM. *Частично выполнен (функциональность есть, реализация неверная)*.
*   ✅ **13) Индикатор наличия товара в корзине:** Реализовано через свойство `IsAvailable` в модели `Cart` и конвертеры `BoolToStatusConverter`, `BoolToColorConverter`.
*   ❌ **14) Редактирование профиля по ПКМ:** Логика для переключения `IsReadOnly` есть в `ProfilePageView.cs`, но обработчик `OnTextBoxPointerPressed` не привязан к элементам `TextBox` в `ProfilePageView.axaml`. *Не выполнен*.
*   ❌ **15) Валидация формата почты и телефона в профиле:** Логика валидации есть в модели `UserProfile`, но она не интегрирована с UI Avalonia для автоматического отображения ошибок (например, через `INotifyDataErrorInfo` или DataAnnotations и стили `:invalid`). *Частично выполнен (логика есть, интеграция с UI неполная)*.
*   ✅ **16) Использование MVVM Community Toolkit / ReactiveUI:** Использован MVVM Community Toolkit.

**Итог по критериям:**
*   Полностью выполнено: 9 из 16
*   Частично выполнено (функциональность есть, но реализация не соответствует MVVM/требованиям или неполная): 4 из 16 (№ 2, 4, 12, 15)
*   Не выполнено: 3 из 16 (№ 7, 8, 14)

**3) Объем выполненного задания**

Учитывая, что некоторые ключевые требования (DI/IoC, правильная реализация MVVM без code-behind, поддержка Web) не выполнены или выполнены некорректно, но основной функционал UI и взаимодействия с API реализован, можно оценить объем выполненного задания примерно в **65-70%**.

Кандидат справился с созданием UI и базовой логикой, но не продемонстрировал глубокого понимания и строгого следования паттерну MVVM и сопутствующим практикам (DI/IoC), которые были явно указаны в требованиях.

---

С уважением,
Артем Кошко, ведущий разработчик проекта